-- Основной файл схемы БД с обратной совместимостью

-- Устанавливаем кодировку и настройки
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;

-- Создаем типы данных если они не существуют
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
    CREATE TYPE user_role AS ENUM ('user', 'editor', 'admin');
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'publication_type') THEN
    CREATE TYPE publication_type AS ENUM ('article', 'news');
  END IF;
END$$;

-- Создаем таблицу users с проверкой существующих колонок
CREATE TABLE IF NOT EXISTS users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username VARCHAR(50) NOT NULL,
  email VARCHAR(100) NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  role user_role DEFAULT 'user',
  bio TEXT,
  avatar_url TEXT DEFAULT '/img/default-avatar.jpg',
  rated_games INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT uq_users_username UNIQUE (username),
  CONSTRAINT uq_users_email UNIQUE (email)
);

-- Добавляем отсутствующие колонки в users если они есть
DO $$
BEGIN
  -- Добавляем колонку bio если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'users' AND column_name = 'bio') THEN
    ALTER TABLE users ADD COLUMN bio TEXT;
  END IF;
  
  -- Добавляем колонку rated_games если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'users' AND column_name = 'rated_games') THEN
    ALTER TABLE users ADD COLUMN rated_games INTEGER DEFAULT 0;
  END IF;
  
  -- Добавляем колонку avatar_url если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'users' AND column_name = 'avatar_url') THEN
    ALTER TABLE users ADD COLUMN avatar_url TEXT DEFAULT '/img/default-avatar.jpg';
  END IF;
END$$;

-- Создаем таблицу games с улучшенной структурой
CREATE TABLE IF NOT EXISTS games (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR(100) NOT NULL,
  description TEXT,
  developers TEXT[], -- Изменяем на массив для хранения нескольких разработчиков
  publishers TEXT[], -- Изменяем на массив для хранения нескольких издателей
  slug VARCHAR(100),
  release_date DATE,
  rating NUMERIC(3,2) DEFAULT 0, -- Изменяем на NUMERIC(3,2) для более точного рейтинга
  background_image TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS comment_likes (
    user_id INT NOT NULL,
    comment_id INT NOT NULL,
    PRIMARY KEY (user_id, comment_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE
);

-- Добавляем отсутствующие колонки в games
DO $$
BEGIN
  -- Меняем тип developers на TEXT[] если он еще VARCHAR
  IF EXISTS (SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'games' AND column_name = 'developers' 
            AND data_type = 'character varying') THEN
    -- Создаем временную колонку
    ALTER TABLE games ADD COLUMN developers_temp TEXT[];
    
    -- Конвертируем данные
    UPDATE games SET developers_temp = ARRAY[developers] WHERE developers IS NOT NULL;
    
    -- Удаляем старую колонку
    ALTER TABLE games DROP COLUMN developers;
    
    -- Переименовываем временную колонку
    ALTER TABLE games RENAME COLUMN developers_temp TO developers;
  END IF;
  
  -- Меняем тип publishers на TEXT[] если он еще VARCHAR
  IF EXISTS (SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'games' AND column_name = 'publishers' 
            AND data_type = 'character varying') THEN
    -- Создаем временную колонку
    ALTER TABLE games ADD COLUMN publishers_temp TEXT[];
    
    -- Конвертируем данные
    UPDATE games SET publishers_temp = ARRAY[publishers] WHERE publishers IS NOT NULL;
    
    -- Удаляем старую колонку
    ALTER TABLE games DROP COLUMN publishers;
    
    -- Переименовываем временную колонку
    ALTER TABLE games RENAME COLUMN publishers_temp TO publishers;
  END IF;
  
  -- Изменяем тип rating если он еще NUMERIC(2,1)
  IF EXISTS (SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'games' AND column_name = 'rating' 
            AND numeric_precision = 2 AND numeric_scale = 1) THEN
    ALTER TABLE games ALTER COLUMN rating TYPE NUMERIC(3,2);
  END IF;
  
  -- Добавляем колонку updated_at если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'games' AND column_name = 'updated_at') THEN
    ALTER TABLE games ADD COLUMN updated_at TIMESTAMPTZ DEFAULT now();
  END IF;
  
  -- Добавляем колонку rating с дефолтным значением если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'games' AND column_name = 'rating') THEN
    ALTER TABLE games ADD COLUMN rating NUMERIC(3,2) DEFAULT 0;
  END IF;
END$$;

-- Создаем индексы для games
CREATE INDEX IF NOT EXISTS idx_games_title ON games(title);
CREATE INDEX IF NOT EXISTS idx_games_slug ON games(slug);
CREATE INDEX IF NOT EXISTS idx_games_rating ON games(rating DESC);
CREATE INDEX IF NOT EXISTS idx_games_release_date ON games(release_date DESC);

-- Создаем таблицу genres (только id и название)
CREATE TABLE IF NOT EXISTS genres (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(50) NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Создаем таблицу game_genres
CREATE TABLE IF NOT EXISTS game_genres (
  game_id BIGINT NOT NULL,
  genre_id BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (game_id, genre_id),
  CONSTRAINT fk_game_genres_game FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE,
  CONSTRAINT fk_game_genres_genre FOREIGN KEY (genre_id) REFERENCES genres(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_game_genres_game_id ON game_genres(game_id);
CREATE INDEX IF NOT EXISTS idx_game_genres_genre_id ON game_genres(genre_id);

-- Создаем таблицу favorites
CREATE TABLE IF NOT EXISTS favorites (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,
  game_id BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT uq_favorites_user_game UNIQUE (user_id, game_id),
  CONSTRAINT fk_favorites_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT fk_favorites_game FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_favorites_user_id ON favorites(user_id);
CREATE INDEX IF NOT EXISTS idx_favorites_game_id ON favorites(game_id);

-- Создаем таблицу publications
CREATE TABLE IF NOT EXISTS publications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,
  game_id BIGINT,
  image VARCHAR(255),
  type publication_type NOT NULL,
  title VARCHAR(150) NOT NULL,
  content TEXT NOT NULL,
  views INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT fk_publications_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT fk_publications_game FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE SET NULL
);

-- Добавляем отсутствующие колонки в publications
DO $$
BEGIN
  -- Добавляем колонку image если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'publications' AND column_name = 'image') THEN
    ALTER TABLE publications ADD COLUMN image VARCHAR(255);
  END IF;
  
  -- Добавляем колонку views если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'publications' AND column_name = 'views') THEN
    ALTER TABLE publications ADD COLUMN views INTEGER DEFAULT 0;
  END IF;
  
  -- Добавляем колонку likes если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'publications' AND column_name = 'likes') THEN
    ALTER TABLE publications ADD COLUMN likes INTEGER DEFAULT 0;
  END IF;
  
  -- Добавляем колонку updated_at если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'publications' AND column_name = 'updated_at') THEN
    ALTER TABLE publications ADD COLUMN updated_at TIMESTAMPTZ DEFAULT now();
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_publications_user_id ON publications(user_id);
CREATE INDEX IF NOT EXISTS idx_publications_game_id ON publications(game_id);
CREATE INDEX IF NOT EXISTS idx_publications_type ON publications(type);
CREATE INDEX IF NOT EXISTS idx_publications_created_at ON publications(created_at DESC);

-- Создаем таблицу reviews с улучшенной структурой
CREATE TABLE IF NOT EXISTS reviews (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,
  game_id BIGINT NOT NULL,
  rating INTEGER NOT NULL,
  content TEXT NOT NULL,
  is_edited BOOLEAN DEFAULT FALSE,
  likes INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT fk_reviews_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT fk_reviews_game FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE,
  CONSTRAINT uq_reviews_user_game UNIQUE (user_id, game_id), -- Один отзыв на игру от пользователя
  CONSTRAINT chk_reviews_rating CHECK (rating BETWEEN 1 AND 5)
);

-- Добавляем отсутствующие колонки в reviews
DO $$
BEGIN
  -- Добавляем колонку is_edited если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'reviews' AND column_name = 'is_edited') THEN
    ALTER TABLE reviews ADD COLUMN is_edited BOOLEAN DEFAULT FALSE;
  END IF;
  
  -- Добавляем колонку likes если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'reviews' AND column_name = 'likes') THEN
    ALTER TABLE reviews ADD COLUMN likes INTEGER DEFAULT 0;
  END IF;
  
  -- Добавляем колонку updated_at если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'reviews' AND column_name = 'updated_at') THEN
    ALTER TABLE reviews ADD COLUMN updated_at TIMESTAMPTZ DEFAULT now();
  END IF;
  
  -- Добавляем уникальное ограничение user_id + game_id если его нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints 
                WHERE table_name = 'reviews' AND constraint_name = 'uq_reviews_user_game') THEN
    ALTER TABLE reviews ADD CONSTRAINT uq_reviews_user_game UNIQUE (user_id, game_id);
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_reviews_user_id ON reviews(user_id);
CREATE INDEX IF NOT EXISTS idx_reviews_game_id ON reviews(game_id);
CREATE INDEX IF NOT EXISTS idx_reviews_rating ON reviews(rating);
CREATE INDEX IF NOT EXISTS idx_reviews_created_at ON reviews(created_at DESC);

-- Создаем таблицу screenshots (только id, game_id, url, created_at)
CREATE TABLE IF NOT EXISTS screenshots (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  game_id BIGINT NOT NULL,
  url TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT fk_screenshots_game FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_screenshots_game_id ON screenshots(game_id);

-- Создаем таблицу comments
CREATE TABLE IF NOT EXISTS comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,
  publication_id BIGINT NOT NULL,
  parent_id BIGINT, -- Для вложенных комментариев
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT fk_comments_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT fk_comments_publication FOREIGN KEY (publication_id) REFERENCES publications(id) ON DELETE CASCADE,
  CONSTRAINT fk_comments_parent FOREIGN KEY (parent_id) REFERENCES comments(id) ON DELETE CASCADE
);

-- Добавляем отсутствующие колонки в comments
DO $$
BEGIN
  -- Добавляем колонку parent_id если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'comments' AND column_name = 'parent_id') THEN
    ALTER TABLE comments ADD COLUMN parent_id BIGINT;
    
    -- Добавляем внешний ключ
    ALTER TABLE comments ADD CONSTRAINT fk_comments_parent 
      FOREIGN KEY (parent_id) REFERENCES comments(id) ON DELETE CASCADE;
  END IF;
  
  -- Добавляем колонку likes если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'comments' AND column_name = 'likes') THEN
    ALTER TABLE comments ADD COLUMN likes INTEGER DEFAULT 0;
  END IF;
  
  -- Добавляем колонку updated_at если ее нет
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                WHERE table_name = 'comments' AND column_name = 'updated_at') THEN
    ALTER TABLE comments ADD COLUMN updated_at TIMESTAMPTZ DEFAULT now();
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_comments_user_id ON comments(user_id);
CREATE INDEX IF NOT EXISTS idx_comments_publication_id ON comments(publication_id);
CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments(parent_id);
CREATE INDEX IF NOT EXISTS idx_comments_created_at ON comments(created_at DESC);

-- Создаем таблицу password_reset_codes
CREATE TABLE IF NOT EXISTS password_reset_codes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,
  code VARCHAR(6) NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT fk_password_reset_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT uq_password_reset_user UNIQUE (user_id)
);

CREATE INDEX IF NOT EXISTS idx_password_reset_user_id ON password_reset_codes(user_id);
CREATE INDEX IF NOT EXISTS idx_password_reset_expires_at ON password_reset_codes(expires_at);

-- Создаем таблицу email_change_codes
CREATE TABLE IF NOT EXISTS email_change_codes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,
  old_email VARCHAR(100) NOT NULL,
  verification_code VARCHAR(6) NOT NULL,
  new_email VARCHAR(100),
  new_email_code VARCHAR(6),
  step VARCHAR(20) NOT NULL DEFAULT 'verify_old',
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT fk_email_change_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT uq_email_change_user UNIQUE (user_id)
);

CREATE INDEX IF NOT EXISTS idx_email_change_user_id ON email_change_codes(user_id);
CREATE INDEX IF NOT EXISTS idx_email_change_expires_at ON email_change_codes(expires_at);

-- Создаем таблицу favorites_genres
CREATE TABLE IF NOT EXISTS favorites_genres (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL,
  genre_id BIGINT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT uq_favorites_genres_user_genre UNIQUE (user_id, genre_id),
  CONSTRAINT fk_favorites_genres_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT fk_favorites_genres_genre FOREIGN KEY (genre_id) REFERENCES genres(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_favorites_genres_user_id ON favorites_genres(user_id);
CREATE INDEX IF NOT EXISTS idx_favorites_genres_genre_id ON favorites_genres(genre_id);

CREATE TABLE IF NOT EXISTS publication_likes (
    user_id BIGINT NOT NULL,
    publication_id BIGINT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (user_id, publication_id),
    CONSTRAINT fk_pub_likes_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_pub_likes_pub FOREIGN KEY (publication_id) REFERENCES publications(id) ON DELETE CASCADE
);

-- ============================================================================
-- ФУНКЦИИ И ТРИГГЕРЫ ДЛЯ АВТОМАТИЧЕСКОГО ОБНОВЛЕНИЯ РЕЙТИНГА ИГРЫ
-- ============================================================================

-- Функция для обновления рейтинга игры
CREATE OR REPLACE FUNCTION update_game_rating()
RETURNS TRIGGER AS $$
DECLARE
    target_game_id BIGINT;
    avg_rating NUMERIC(3,2);
BEGIN
    -- Определяем ID игры для обновления
    IF (TG_OP = 'DELETE') THEN
        target_game_id := OLD.game_id;
    ELSE
        target_game_id := NEW.game_id;
    END IF;
    
    -- Рассчитываем средний рейтинг
    SELECT COALESCE(AVG(rating), 0) INTO avg_rating
    FROM reviews 
    WHERE game_id = target_game_id;
    
    -- Обновляем рейтинг игры
    UPDATE games 
    SET 
        rating = ROUND(avg_rating, 2),
        updated_at = NOW()
    WHERE id = target_game_id;
    
    -- Обновляем количество оцененных игр у пользователя
    IF (TG_OP = 'INSERT') THEN
        UPDATE users 
        SET rated_games = rated_games + 1
        WHERE id = NEW.user_id;
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE users 
        SET rated_games = GREATEST(rated_games - 1, 0)
        WHERE id = OLD.user_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Удаляем старые триггеры если они существуют
DROP TRIGGER IF EXISTS update_game_rating_on_insert ON reviews;
DROP TRIGGER IF EXISTS update_game_rating_on_update ON reviews;
DROP TRIGGER IF EXISTS update_game_rating_on_delete ON reviews;

-- Создаем триггеры для автоматического обновления рейтинга
CREATE TRIGGER update_game_rating_on_insert
AFTER INSERT ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_game_rating();

CREATE TRIGGER update_game_rating_on_update
AFTER UPDATE ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_game_rating();

CREATE TRIGGER update_game_rating_on_delete
AFTER DELETE ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_game_rating();

-- ============================================================================
-- ФУНКЦИЯ ДЛЯ ОБНОВЛЕНИЯ ВСЕХ РЕЙТИНГОВ ИГР (ДЛЯ МИГРАЦИИ)
-- ============================================================================

CREATE OR REPLACE FUNCTION update_all_games_ratings()
RETURNS VOID AS $$
BEGIN
    UPDATE games g
    SET rating = COALESCE(
        (SELECT ROUND(AVG(r.rating), 2)
         FROM reviews r
         WHERE r.game_id = g.id
         GROUP BY r.game_id),
        0
    ),
    updated_at = NOW()
    WHERE EXISTS (SELECT 1 FROM reviews r WHERE r.game_id = g.id);
    
    RAISE NOTICE 'Обновлены рейтинги всех игр';
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ФУНКЦИИ ДЛЯ ОБНОВЛЕНИЯ TIMESTAMP
-- ============================================================================

-- Функция для обновления updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггеры для автоматического обновления updated_at
DROP TRIGGER IF EXISTS update_games_updated_at ON games;
CREATE TRIGGER update_games_updated_at
BEFORE UPDATE ON games
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_reviews_updated_at ON reviews;
CREATE TRIGGER update_reviews_updated_at
BEFORE UPDATE ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_publications_updated_at ON publications;
CREATE TRIGGER update_publications_updated_at
BEFORE UPDATE ON publications
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_comments_updated_at ON comments;
CREATE TRIGGER update_comments_updated_at
BEFORE UPDATE ON comments
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
-- ============================================================================

-- Функция для получения средней оценки игры
CREATE OR REPLACE FUNCTION get_game_avg_rating(game_id_param BIGINT)
RETURNS NUMERIC(3,2) AS $$
DECLARE
    avg_rating NUMERIC(3,2);
BEGIN
    SELECT COALESCE(ROUND(AVG(rating), 2), 0) INTO avg_rating
    FROM reviews
    WHERE game_id = game_id_param;
    
    RETURN avg_rating;
END;
$$ LANGUAGE plpgsql;

-- Функция для получения статистики игры
CREATE OR REPLACE FUNCTION get_game_stats(game_id_param BIGINT)
RETURNS TABLE (
    total_reviews BIGINT,
    avg_rating NUMERIC(3,2),
    five_stars BIGINT,
    four_stars BIGINT,
    three_stars BIGINT,
    two_stars BIGINT,
    one_star BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_reviews,
        COALESCE(ROUND(AVG(rating), 2), 0) as avg_rating,
        COUNT(CASE WHEN rating = 5 THEN 1 END) as five_stars,
        COUNT(CASE WHEN rating = 4 THEN 1 END) as four_stars,
        COUNT(CASE WHEN rating = 3 THEN 1 END) as three_stars,
        COUNT(CASE WHEN rating = 2 THEN 1 END) as two_stars,
        COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star
    FROM reviews
    WHERE game_id = game_id_param
    GROUP BY game_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ЗАВЕРШЕНИЕ МИГРАЦИИ
-- ============================================================================

-- Вызываем функцию для обновления всех рейтингов игр
SELECT update_all_games_ratings();

-- Выводим информацию о завершении
DO $$
BEGIN
    RAISE NOTICE '=========================================';
    RAISE NOTICE 'Миграция базы данных успешно завершена!';
    RAISE NOTICE '=========================================';
    RAISE NOTICE 'Созданы/обновлены:';
    RAISE NOTICE '- Триггеры для автоматического обновления рейтинга игр';
    RAISE NOTICE '- Функции для работы с рейтингами';
    RAISE NOTICE '- Все необходимые индексы';
    RAISE NOTICE '- Улучшенная структура таблиц';
    RAISE NOTICE '=========================================';
END $$;